<a class="anchor" id="projects"></a>
<section class="content-section projects">
    <div class="page-contain projects-inner">
        <h2 class="project-header">Current Projects</h2>
        <p class="project-pitch">
            Have an idea?
            <a href="mailto:team@hackforla.org" class="btn btn-primary btn-md-narrow">Submit your pitch</a>
        </p>
    </div>
    <div class="page-contain filter-toolbar">
        <ul class="filter-list" id="filter-list"></ul>
    </div>
    <div class="page-contain projects-inner" style="clear: left;">
      <ul class="project-list unstyled-list">
        {% assign status_list = "Active, Rebooting, Completed, On Hold" | split: ", " %}
        {% for status in status_list %}
          {% assign projects = site.projects | where: "status", status | sort: "title" %}
          {%- for item in projects -%}
            {%- if item.visible == true -%}
              {%- include project-card.html project=item -%}
            {%- endif -%}
          {%- endfor -%}
        {%- endfor -%}
      </ul>
    </div>
</section>
<script>
{% assign visible_projects = site.projects | where: "visible", "true" %}
var projectDataFromJekyll = [{%- for project in visible_projects -%}
      {
        "id": {{ project.identification | default: 0 }},
        "status": ["{{ project.status }}"]
        {%- if project.location -%},
        "location": {{ project.location | jsonify }}
        {%-endif -%}
        {%- if project.looking -%},
        "looking": {{ project.looking | jsonify }}
        {%-endif -%}
        {%- if project.technologies -%},
        "technologies": {{ project.technologies | jsonify }}
        {%- endif -%}
      } {%- unless forloop.last -%}, {% endunless %}
    {% endfor %}];

window.addEventListener('load', function() {

    //detect touchscreen/non-touchscreen
    let touch;
    if ("ontouchstart" in document.documentElement) {
        touch = true;
    } else {
        touch = false;
    }


    // utilities
    const cleanFieldName = (category, term) => `${category}_${term.replace(/\s+/g, '_').replace(/[^a-zA-Z0-9_]/g, '')}`;
    const onlyUnique = (value, index, self) => self.indexOf(value) === index;

    const projects = projectDataFromJekyll.map(record => {
        let lookingCategories = [];
        if (record.looking) {
            lookingCategories = record.looking.map(x => x.category);
        }
        record.looking = lookingCategories.filter(onlyUnique);
        return new Project(record);
    });

    const filterableCategories = ['status', 'looking', 'technologies', 'location'];

    // Collect all possible filter values for count computation
    let valuesByCategory = new Map();
    filterableCategories.forEach(cat => {
        valuesByCategory.set(cat, new Set())
    });
    projects.forEach(p => {
        for (let key in p.data) {
            if (!filterableCategories.includes(key)) {
                continue;
            }
            for (let v in p.data[key]) {
                valuesByCategory.get(key).add(p.data[key][v]);
            }
        }
    });


    // Hide cards not satisfying filter, update counts in dropdowns
    function applyFilter(filterReport) {

        // hide projects not satisfying filter constraints
        document.querySelectorAll(".project-card").forEach(element => {
            if (filterReport.ids.indexOf(parseInt(element.id)) < 0) {
                element.setAttribute('class', 'project-card hidden-project');
            } else {
                element.setAttribute('class', 'project-card');
            }
        });


        // Assign updated counts to dropdown text
        for (let category in filterReport.counts) {
            const termCounts = filterReport.counts[category];
            for (let term in termCounts) {
                // const cleanName = `${category}_${term.replace(/\s+/g, '_').replace(/[^a-zA-Z0-9_]/g, '')}`;
                const cleanName = cleanFieldName(category, term);
                const text = `${term} (${termCounts[term]})`;
                document.getElementById(cleanName).innerHTML = text;
            }
        }

    }

    // initialize project filter and get initial report (no filters applied yet)
    const projectFilter = new ProjectFilter(valuesByCategory);
    
    //Sorts the filters in alphabetical order
    for(const [key,value] of projectFilter.valuesByCategory){
        let ls = [...projectFilter.valuesByCategory.get(key)].sort();
        ls = new Set(ls)
        projectFilter.valuesByCategory.set(key,ls)
    }
    
    projectFilter.populateFromUrlParams();
    let report = projectFilter.getFilterReport(projects);
    console.log(ProjectFilter.prototype)
    console.log(projectFilter)

    // create parentNode for filterTags
    const filterFragment = document.createDocumentFragment()
    const filterToolbar = document.querySelector('.filter-toolbar')

    // create clearAll
    const clearAll = document.createElement('a')
    const renderClearAll = (clearAll) => {
        if(!document.querySelector('.clear-filter-tags')){
            clearAll.textContent = 'Clear All'
            clearAll.setAttribute('class', 'clear-filter-tags')
            clearAll.style.whiteSpace = 'nowrap' 
        }
    }
    // functions for filters
    const updateCategoryInnerHTML = (categoryTitle, category, checkedboxCounter) => {
        if(checkedboxCounter > 0) {categoryTitle = categoryTitle.innerHTML = `
            ${category}
            <span class="number-of-checked-boxes">
                (${checkedboxCounter})
            </span> 
            <span class="labelArrow"> ∟ </span> 
        `}
         else if (checkedboxCounter <= 0) {
            categoryTitle.innerHTML = `
                ${category}
                <span class="labelArrow"> ∟ </span> 
                `
        } 
    }
//FIXME: connect to URL Params
    const removeAllFilterTags = () => {
        const filters = document.querySelectorAll('.btn--current-projects-filter-tag')
        filters.forEach(filter => filter.parentNode.removeChild(filter))
    }
//FIXME: connect to URL Params
    const removeFilterTag = event => {
        const checkboxId =
            event.target.nextElementSibling.getAttribute('id')
        const filterTagKey =
            document.querySelector(`[data-key~=${checkboxId}]`)
        
        if (!filterTagKey) { return }
        filterTagKey.remove()
    }
//FIXME: connect to URL Params
    const removeClearAll = () => {
        document.querySelector('.clear-filter-tags').innerHTML = ''
        clearAll.remove()
    }
//FIXME: connect to URL Params
    const removeAllChecks = () => {
        const checkboxes = document.querySelectorAll('.filter-checkbox')
        if(null){return}
        checkboxes.forEach(check => check.checked = false)
    } 
    
        // Render the filter toolbar - depending on screensize
    for (let category in report.counts) {

        const termSet = report.counts[category];
        
        // dropdown container - menu item
        const categoryDropdown = document.createElement('li');
        categoryDropdown.setAttribute('class', 'filter-item');

        // dropdown label/trigger element
        const categoryTitle = document.createElement('a');
        categoryTitle.appendChild(document.createTextNode(category));
        categoryDropdown.appendChild(categoryTitle);

        // dropdown menu
        const termList = document.createElement('ul')
        termList.setAttribute('class', 'dropdown');

        // create label arrow
        const arrowSpan = document.createElement('span');
        const labelArrow = arrowSpan.appendChild(document.createTextNode(" \u{0221f} "));
        arrowSpan.setAttribute('class', 'labelArrow');
        categoryTitle.appendChild(arrowSpan);

        //counter for checkedboxes
        let checkedboxCounter = 0;

        const removeUrlParam = (category, term) => {
            projectFilter.removeCondition(category, term);
            report = projectFilter.getFilterReport(projects);
            applyFilter(report);
            projectFilter.propagateUrlParams();
        }

        for (let term in termSet) {
            const count = termSet[term];
            const termItem = document.createElement('li');
            const content = document.createElement('div');
            const checkbox = document.createElement('input');


            checkbox.setAttribute('type', 'checkbox');
            checkbox.setAttribute('class', 'filter-checkbox');

            const text = `${term} (${count})`;
            const textSpan = document.createElement('span');

            // TODO: Find a better mechanism for indexing dropdown items
            textSpan.setAttribute('id', cleanFieldName(category, term));
            textSpan.innerHTML = text;

            // console.log(projectFilter)
            
            checkbox.addEventListener('input', function(event) {
                if (event.target.checked) {
                    projectFilter.addCondition(category, term);
                    console.log(projectFilter.conditions)
                    checkedboxCounter++;
//FIXME: !!! 
                    const categoryCapitalized = category.charAt(0).toUpperCase() + category.slice(1)
                    const filterTags = document.createElement('button') 
                    const grabCheckboxId = event.target.nextElementSibling.getAttribute('id')
                    renderClearAll(clearAll)

                    //creates filterTags
                    filterTags.setAttribute('data-key', `${grabCheckboxId}`)
                    filterTags.setAttribute('class', 'btn--current-projects-filter-tag')
                    filterTags.innerHTML = `${categoryCapitalized}: ${term}`
                    filterFragment.appendChild(filterTags)
                    filterFragment.appendChild(clearAll)
                    filterToolbar.insertBefore(filterFragment, filterToolbar[0])
                    
                    updateCategoryInnerHTML(categoryTitle, category, checkedboxCounter)
                    filterTags.addEventListener('click', function (event) {
                        if (event.target.classList.contains('btn--current-projects-filter-tag')) {
                            let updateConditions
                            const filterTagKey = event.target.getAttribute('data-key')
                            const checkboxId = document.querySelector(`#${filterTagKey}`)

                            event.target.remove()
                            checkboxId.previousElementSibling.checked = false
                            
                            removeUrlParam(category, term)
                            
                        }
                    })
                } else {
    // FIXME: connect unChecks to URL Params — sometimes works, sometimes doesn't
                    projectFilter.removeCondition(category, term);
                    checkedboxCounter--;
                    console.log(projectFilter.conditions)

                    removeFilterTag(event)
                    updateCategoryInnerHTML(categoryTitle, category, checkedboxCounter)
                    
                    // if all inputs unChecked, removeClearAll
                    if (document.querySelectorAll('input[type=checkbox]:checked').length == 0) {
                        removeClearAll()
                    }   
                }
    // FIXME: CONNECT TO URL PARAMS
                // resets all changes on click
                clearAll.addEventListener('click', function () {
                    removeAllFilterTags()
                    removeClearAll()
                    removeAllChecks()
                    removeUrlParam(category, term)
                })
    // FIXME: connect to URL Params && category title 
                // resets changes when filterTag is removed
                //TODO: find better way to execute this code
                // document.addEventListener('click', function(event){
                //     if (event.target.classList.contains('btn--current-projects-filter-tag')) {
                //         let updateConditions
                //         const filterTagKey = event.target.getAttribute('data-key')
                //         const checkboxId = document.querySelector(`#${filterTagKey}`)

                //         event.target.remove()
                //         checkboxId.previousElementSibling.checked = false
                        
                //         // removeCondition is working
                //         // need to figure out how to _return_ / _update_ the change
                //         // specifically for applying to report 
                //         console.log(event.target.parentNode)
                //         projectFilter.removeCondition(category, term);
                //         console.log(projectFilter.conditions)
                //         // console.log(report)
                //         // console.log(projectFilter.conditions)
                //         report = projectFilter.getFilterReport(projects);
                //         applyFilter(report);
                //         // console.log(report)
                //         projectFilter.propagateUrlParams();
                //     }
                // })
            
            console.log(report)
                // recompute counts and IDs to hide
                report = projectFilter.getFilterReport(projects);
                applyFilter(report);
            console.log(report)
                projectFilter.propagateUrlParams();
                // console.log(projectFilter.propagateUrlParams())
            });
            
            // finalize build UI component
            content.appendChild(checkbox);
            content.appendChild(textSpan);
            termItem.appendChild(content);
            termList.appendChild(termItem);
        }

        // compile DOM node and attach to document tree
        categoryDropdown.appendChild(termList);
        document.querySelector("#filter-list").appendChild(categoryDropdown);
    }

    if (touch) {
        const filterList = document.querySelector(".filter-list");
        const filterItem = filterList.children;
        const clickedItems = [];
        for (let x = 0; x < filterItem.length; x++) {
            filterItem[x].addEventListener("click", function() {
                clickedItems.push(filterItem[x]);
                filterItem[x].children[1].style = "opacity: 1; visibility: visible;";

                setTimeout(function() {
                    filterItem[x].children[1].style = "opacity: 0; visibility: hidden;";
                }, 3000)
            })
        }
    }


    for (let [categoryName, valueSet] of projectFilter.conditions.entries()) {
        if (valueSet.size > 0) {
            for (let v of valueSet) {
                const cleanName = cleanFieldName(categoryName, v);
                document.getElementById(cleanName).previousSibling.checked = true;
            }
        }
    }

    applyFilter(report);

    });
</script>